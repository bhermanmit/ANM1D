function [reg1,reg2] = ANM_compute_discontinuity(reg1,reg2,dfs)

% geometry
L1 = reg1.L;
L2 = reg2.L;

% compute removal cross sections
reg(1).sigr1 = reg1.sigt(1) - reg1.sigs(1,1);
reg(1).sigr2 = reg1.sigt(2) - reg1.sigs(2,2);
reg(2).sigr1 = reg2.sigt(1) - reg2.sigs(1,1);
reg(2).sigr2 = reg2.sigt(2) - reg2.sigs(2,2);

% resave other data in the structure below
reg(1).sigs12 = reg1.sigs(1,2);
reg(1).sigs21 = reg1.sigs(2,1);
reg(1).nsigf1 = reg1.nsigf(1);
reg(1).nsigf2 = reg1.nsigf(2);
reg(1).D1 = reg1.diff(1);
reg(1).D2 = reg1.diff(2);
reg(2).sigs12 = reg2.sigs(1,2);
reg(2).sigs21 = reg2.sigs(2,1);
reg(2).nsigf1 = reg2.nsigf(1);
reg(2).nsigf2 = reg2.nsigf(2);
reg(2).D1 = reg2.diff(1);
reg(2).D2 = reg2.diff(2);

% create lambda functions
reg(1).lamb1 = @(k) -reg(1).sigr2/(2*reg(1).D2) ...
    - reg(1).sigr1/(2*reg(1).D1) ...
    + reg(1).nsigf1/(2*reg(1).D1*k) ...
    + (reg(1).sigr2^2/(4*reg(1).D2^2) ...
    - reg(1).sigr1*reg(1).sigr2/(2*reg(1).D1*reg(1).D2) ...
    + reg(1).sigs12*reg(1).sigs21/(reg(1).D1*reg(1).D2) ...
    + reg(1).nsigf1*reg(1).sigr2/(2*reg(1).D1*reg(1).D2*k) ...
    + reg(1).nsigf2*reg(1).sigs12/(reg(1).D1*reg(1).D2*k) ...
    + reg(1).sigr1^2/(4*reg(1).D1^2) ...
    - reg(1).nsigf1*reg(1).sigr1/(2*reg(1).D1^2*k) ...
    + reg(1).nsigf1^2/(4*reg(1).D1^2*k^2))^(0.5);

reg(1).lamb2 = @(k) -reg(1).sigr2/(2*reg(1).D2) ...
    - reg(1).sigr1/(2*reg(1).D1) ...
    + reg(1).nsigf1/(2*reg(1).D1*k) ...
    - (reg(1).sigr2^2/(4*reg(1).D2^2) ...
    - reg(1).sigr1*reg(1).sigr2/(2*reg(1).D1*reg(1).D2) ...
    + reg(1).sigs12*reg(1).sigs21/(reg(1).D1*reg(1).D2) ...
    + reg(1).nsigf1*reg(1).sigr2/(2*reg(1).D1*reg(1).D2*k) ...
    + reg(1).nsigf2*reg(1).sigs12/(reg(1).D1*reg(1).D2*k) ...
    + reg(1).sigr1^2/(4*reg(1).D1^2) ...
    - reg(1).nsigf1*reg(1).sigr1/(2*reg(1).D1^2*k) ...
    + reg(1).nsigf1^2/(4*reg(1).D1^2*k^2))^(0.5);

reg(2).lamb1 = @(k) -reg(2).sigr2/(2*reg(2).D2) ...
    - reg(2).sigr1/(2*reg(2).D1) ...
    + reg(2).nsigf1/(2*reg(2).D1*k) ...
    + (reg(2).sigr2^2/(4*reg(2).D2^2) ...
    - reg(2).sigr1*reg(2).sigr2/(2*reg(2).D1*reg(2).D2) ...
    + reg(2).sigs12*reg(2).sigs21/(reg(2).D1*reg(2).D2) ...
    + reg(2).nsigf1*reg(2).sigr2/(2*reg(2).D1*reg(2).D2*k) ...
    + reg(2).nsigf2*reg(2).sigs12/(reg(2).D1*reg(2).D2*k) ...
    + reg(2).sigr1^2/(4*reg(2).D1^2) ...
    - reg(2).nsigf1*reg(2).sigr1/(2*reg(2).D1^2*k) ...
    + reg(2).nsigf1^2/(4*reg(2).D1^2*k^2))^(0.5);

reg(2).lamb2 = @(k) -reg(2).sigr2/(2*reg(2).D2) ...
    - reg(2).sigr1/(2*reg(2).D1) ...
    + reg(2).nsigf1/(2*reg(2).D1*k) ...
    - (reg(2).sigr2^2/(4*reg(2).D2^2) ...
    - reg(2).sigr1*reg(2).sigr2/(2*reg(2).D1*reg(2).D2) ...
    + reg(2).sigs12*reg(2).sigs21/(reg(2).D1*reg(2).D2) ...
    + reg(2).nsigf1*reg(2).sigr2/(2*reg(2).D1*reg(2).D2*k) ...
    + reg(2).nsigf2*reg(2).sigs12/(reg(2).D1*reg(2).D2*k) ...
    + reg(2).sigr1^2/(4*reg(2).D1^2) ...
    - reg(2).nsigf1*reg(2).sigr1/(2*reg(2).D1^2*k) ...
    + reg(2).nsigf1^2/(4*reg(2).D1^2*k^2))^(0.5);

% create eigenvector matrices
reg(1).v11 = @(k) reg(1).lamb1(k) + reg(1).sigr2/reg(1).D2;
reg(1).v12 = @(k) reg(1).lamb2(k) + reg(1).sigr2/reg(1).D2;
reg(1).v21 = @(k) reg(1).sigs12/reg(1).D2;
reg(1).v22 = @(k) reg(1).sigs12/reg(1).D2;
reg(2).v11 = @(k) reg(2).lamb1(k) + reg(2).sigr2/reg(2).D2;
reg(2).v12 = @(k) reg(2).lamb2(k) + reg(2).sigr2/reg(2).D2;
reg(2).v21 = @(k) reg(2).sigs12/reg(2).D2;
reg(2).v22 = @(k) reg(2).sigs12/reg(2).D2;

% create matrix to solve for coeffs
A1 = @(k) [ [ ...
    reg(1).D1*reg(1).v11(k)*sqrt(reg(1).lamb1(k))*sin(sqrt(reg(1).lamb1(k))*L1), ...
   -reg(1).D1*reg(1).v12(k)*sqrt(-reg(1).lamb2(k))*sinh(sqrt(-reg(1).lamb2(k))*L1)]; ...
   [reg(1).D2*reg(1).v21(k)*sqrt(reg(1).lamb1(k))*sin(sqrt(reg(1).lamb1(k))*L1), ...
   -reg(1).D2*reg(1).v22(k)*sqrt(-reg(1).lamb2(k))*sinh(sqrt(-reg(1).lamb2(k))*L1)] ... 
   ];

b1 = reg1.currR - reg1.currL;

A2 = @(k) [ [ ...
    reg(2).D1*reg(2).v11(k)*sqrt(reg(2).lamb1(k))*sin(sqrt(reg(2).lamb1(k))*L2), ...
   -reg(2).D1*reg(2).v12(k)*sqrt(-reg(2).lamb2(k))*sinh(sqrt(-reg(2).lamb2(k))*L2)]; ...
   [reg(2).D2*reg(2).v21(k)*sqrt(reg(2).lamb1(k))*sin(sqrt(reg(2).lamb1(k))*L2), ...
   -reg(2).D2*reg(2).v22(k)*sqrt(-reg(2).lamb2(k))*sinh(sqrt(-reg(2).lamb2(k))*L2)] ... 
   ];

b2 = reg2.currR - reg2.currL;

coeffs = A1(reg1.keff)\b1;
reg(1).a = coeffs(1);
reg(1).c = coeffs(2);
coeffs = A2(reg2.keff)\b2;
reg(2).a = coeffs(1);
reg(2).c = coeffs(2);

% set up fluxes
reg(1).phi1 = @(x) reg(1).v11(reg1.keff)*reg(1).a*cos(sqrt(reg(1).lamb1(reg1.keff))*x) + ...
    reg(1).v12(reg1.keff)*reg(1).c*cosh(sqrt(-reg(1).lamb2(reg1.keff))*x);
reg(1).phi2 = @(x) reg(1).v21(reg1.keff)*reg(1).a*cos(sqrt(reg(1).lamb1(reg1.keff))*x) + ...
    reg(1).v22(reg1.keff)*reg(1).c*cosh(sqrt(-reg(1).lamb2(reg1.keff))*x);
reg(2).phi1 = @(x) reg(2).v11(reg2.keff)*reg(2).a*cos(sqrt(reg(2).lamb1(reg2.keff))*(x-L2)) + ...
    reg(2).v12(reg2.keff)*reg(2).c*cosh(sqrt(-reg(2).lamb2(reg2.keff))*(x-L2));
reg(2).phi2 = @(x) reg(2).v21(reg2.keff)*reg(2).a*cos(sqrt(reg(2).lamb1(reg2.keff))*(x-L2)) + ...
    reg(2).v22(reg2.keff)*reg(2).c*cosh(sqrt(-reg(2).lamb2(reg2.keff))*(x-L2));


% save fluxes in output object
dx = 6.299200000000001e-02;
meshflux = reg1.meshflux;
if strcmp(dfs,'rdfs')
    meshflux(:,:) = 1;
end
if reg(1).phi1(L1) - 0.0 < 1e-8
   reg(1).phi1 = @(x) reg1.flux(1)/reg1.L;
   reg(1).phi2 = @(x) reg1.flux(2)/reg1.L;
end

reg1.f(1) = meshflux(1,320)/dx/reg(1).phi1(L1);
reg1.f(2) = meshflux(2,320)/dx/reg(1).phi2(L1);
if size(meshflux,2) > 320
    reg2.f(1) = meshflux(1,321)/dx/reg(2).phi1(0);
    reg2.f(2) = meshflux(2,321)/dx/reg(2).phi2(0);
end

% readjust RDFs
if strcmp(dfs,'rdfs')
    c = reg1.f(1)/reg2.f(1);
    reg2.f(1) = 2/(1+c);
    reg1.f(1) = 2 - reg2.f(1);
    c = reg1.f(2)/reg2.f(2);
    reg2.f(2) = 2/(1+c);
    reg1.f(2) = 2 - reg2.f(2);
end

end